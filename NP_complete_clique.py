# -*- coding: utf-8 -*-
"""Max Clique Problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FI1_e-pqHiw3NpVgTja-cCjb8ISLCI-O
"""

pip install dwave-ocean-sdk

import dimod

# Defining the graph as a dictionary
graph = {
    'A': set('BC'),
    'B': set('AC'),
    'C': set('AB'),
    'D': set('E'),
    'E': set('D'),
}

# Creating a QUBO model
qubo = dimod.BinaryQuadraticModel(vartype='SPIN')

# Adding positive terms to encourage selection of connected nodes
for node1 in graph:
    for node2 in graph[node1]:
        if node1 < node2:
            qubo.add_interaction((node1, node2), -1, bias=0)

# Adding negative terms to penalize selection of unconnected nodes
for node1 in graph:
    for node2 in set(graph.keys()) - graph[node1]:
        qubo.add_interaction((node1, node2), 2, bias=0)

# Solving the QUBO using a D-Wave sampler
sampler = dimod.SimulatedAnnealingSampler()
response = sampler.sample(qubo, num_reads=1000)

# Finding the sample with the lowest energy
lowest_energy = min(response.data(['energy']), key=lambda x: x[1] if len(x) > 1 else float('inf'))

# Decoding the solution
clique = set()
for sample, energy in response.data(['sample', 'energy']):
    if energy == lowest_energy:
        for node, value in sample.items():
            if value == 1:
                clique.add(node)
        break

# Print the maximum clique
print(clique)